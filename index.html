<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Minecraft World - Infinite</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
            text-align: center;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 150;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: white;
            border: 1px solid black;
        }

        .crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>Generating Infinite World...</div>
            <div id="loadingProgress">0%</div>
        </div>
        
        <div class="crosshair" id="crosshair" style="display: block;"></div>
        
        <div id="info">
            <h3>üåç Infinite Minecraft World</h3>
            <p>Render Distance: <span id="renderDist">12</span> chunks</p>
            <p>Loaded Chunks: <span id="tileCount">0</span></p>
            <p>Position: <span id="cameraPos">0, 0, 0</span></p>
            <p>Chunk: <span id="currentChunk">0, 0</span></p>
            <p>Grounded: <span id="grounded">Yes</span></p>
        </div>

        <div id="controls">
            <h4>Controls:</h4>
            <p>‚Ä¢ Hold Q,E / Arrow Keys: Look left/right</p>
            <p>‚Ä¢ Hold 1,3 / Up,Down: Look up/down</p>
            <p>‚Ä¢ WASD: Move (infinite world!)</p>
            <p>‚Ä¢ Space: Jump</p>
            <p>‚Ä¢ R: Reset view</p>
        </div>

        <div id="stats">
            <p>FPS: <span id="fps">60</span></p>
            <p>Triangles: <span id="triangles">0</span></p>
            <p>Draw Calls: <span id="drawCalls">0</span></p>
            <p>Generated: <span id="totalGenerated">0</span></p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class InfiniteMap3D {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                this.renderDistance = 12; // Chunks to render around player
                this.tileSize = 10;
                this.tiles = new Map();
                this.tileObjects = new Map(); // Store Three.js objects for cleanup
                
                this.keys = {};
                this.moveSpeed = 0.3;
                this.jumpSpeed = 0;
                this.gravity = -0.02;
                this.isGrounded = false;
                this.playerHeight = 3;
                
                // Camera rotation variables
                this.cameraRotationY = 0;
                this.cameraRotationX = 0;
                this.turnSpeed = 0.03;
                
                // Infinite world variables
                this.currentChunkX = 0;
                this.currentChunkZ = 0;
                this.lastChunkX = 0;
                this.lastChunkZ = 0;
                this.totalChunksGenerated = 0;
                
                this.lastTime = 0;
                this.frameCount = 0;
                this.lastFPSUpdate = 0;
                
                this.groundHeights = new Map();
                this.collisionObjects = [];
                
                this.init();
            }

            init() {
                try {
                    console.log('Initializing Infinite 3D Map...');
                    this.setupScene();
                    this.setupCamera();
                    this.setupRenderer();
                    this.setupLighting();
                    this.setupEventListeners();
                    
                    setTimeout(() => {
                        this.generateInitialChunks();
                        this.finishLoading();
                        this.animate();
                    }, 100);
                    
                } catch (error) {
                    console.error('Error initializing 3D Map:', error);
                    document.getElementById('loading').innerHTML = '<div style="color: red;">Error loading map. Please refresh.</div>';
                }
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 80, 150);
                console.log('Scene created');
            }

            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 15, 15);
                console.log('Camera created');
            }

            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('container').appendChild(this.renderer.domElement);
                console.log('Renderer created');
            }

            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                this.scene.add(directionalLight);
                console.log('Lighting setup complete');
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'KeyR') {
                        this.resetCamera();
                    }
                    if (e.code === 'Space' && this.isGrounded) {
                        this.jumpSpeed = 0.4;
                        this.isGrounded = false;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                console.log('Event listeners setup complete');
            }

            handleCameraRotation() {
                if (this.keys['ArrowLeft'] || this.keys['KeyQ']) {
                    this.cameraRotationY += this.turnSpeed;
                }
                if (this.keys['ArrowRight'] || this.keys['KeyE']) {
                    this.cameraRotationY -= this.turnSpeed;
                }
                if (this.keys['ArrowUp'] || this.keys['Digit1']) {
                    this.cameraRotationX += this.turnSpeed * 0.7;
                    this.cameraRotationX = Math.min(Math.PI/3, this.cameraRotationX);
                }
                if (this.keys['ArrowDown'] || this.keys['Digit3']) {
                    this.cameraRotationX -= this.turnSpeed * 0.7;
                    this.cameraRotationX = Math.max(-Math.PI/3, this.cameraRotationX);
                }

                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.cameraRotationY;
                this.camera.rotation.x = this.cameraRotationX;
                this.camera.rotation.z = 0;
            }

            generateInitialChunks() {
                console.log('Generating initial chunks...');
                const halfDistance = Math.floor(this.renderDistance / 2);
                let chunksGenerated = 0;
                const totalChunks = this.renderDistance * this.renderDistance;
                
                for (let x = -halfDistance; x < halfDistance; x++) {
                    for (let z = -halfDistance; z < halfDistance; z++) {
                        this.createChunk(x, z);
                        chunksGenerated++;
                        
                        const progress = Math.floor((chunksGenerated / totalChunks) * 100);
                        document.getElementById('loadingProgress').textContent = progress + '%';
                    }
                }
                console.log(`Generated ${chunksGenerated} initial chunks`);
            }

            updateInfiniteWorld() {
                // Calculate current chunk position
                this.currentChunkX = Math.floor(this.camera.position.x / this.tileSize);
                this.currentChunkZ = Math.floor(this.camera.position.z / this.tileSize);
                
                // Only update if player moved to a different chunk
                if (this.currentChunkX !== this.lastChunkX || this.currentChunkZ !== this.lastChunkZ) {
                    console.log(`Player moved to chunk ${this.currentChunkX}, ${this.currentChunkZ}`);
                    
                    // Generate new chunks around player
                    this.generateChunksAroundPlayer();
                    
                    // Remove distant chunks
                    this.removeDistantChunks();
                    
                    this.lastChunkX = this.currentChunkX;
                    this.lastChunkZ = this.currentChunkZ;
                }
            }

            generateChunksAroundPlayer() {
                const halfDistance = Math.floor(this.renderDistance / 2);
                
                for (let x = this.currentChunkX - halfDistance; x <= this.currentChunkX + halfDistance; x++) {
                    for (let z = this.currentChunkZ - halfDistance; z <= this.currentChunkZ + halfDistance; z++) {
                        const key = `${x},${z}`;
                        if (!this.tiles.has(key)) {
                            this.createChunk(x, z);
                        }
                    }
                }
            }

            removeDistantChunks() {
                const chunksToRemove = [];
                const maxDistance = this.renderDistance + 2; // Keep a few extra chunks as buffer
                
                this.tiles.forEach((tile, key) => {
                    const [chunkX, chunkZ] = key.split(',').map(Number);
                    const distance = Math.max(
                        Math.abs(chunkX - this.currentChunkX),
                        Math.abs(chunkZ - this.currentChunkZ)
                    );
                    
                    if (distance > maxDistance) {
                        chunksToRemove.push(key);
                    }
                });
                
                // Remove distant chunks
                chunksToRemove.forEach(key => {
                    const objects = this.tileObjects.get(key);
                    if (objects) {
                        objects.forEach(obj => {
                            this.scene.remove(obj);
                            if (obj.geometry) obj.geometry.dispose();
                            if (obj.material) obj.material.dispose();
                        });
                        this.tileObjects.delete(key);
                    }
                    this.tiles.delete(key);
                });
                
                if (chunksToRemove.length > 0) {
                    console.log(`Removed ${chunksToRemove.length} distant chunks`);
                }
            }

            createChunk(x, z) {
                const key = `${x},${z}`;
                if (this.tiles.has(key)) return;

                const chunkObjects = [];

                // Create terrain block
                const geometry = new THREE.BoxGeometry(this.tileSize, 2, this.tileSize);
                
                // Vary terrain colors based on position
                const distance = Math.sqrt(x*x + z*z);
                let color = 0x7CB342; // Default grass green
                
                if (distance > 20) {
                    color = 0x8BC34A; // Light green for distant areas
                } else if (distance > 10) {
                    color = 0x689F38; // Medium green
                }
                
                const material = new THREE.MeshLambertMaterial({ color: color });

                const height = this.getGroundHeight(x * this.tileSize, z * this.tileSize) - 1;
                
                const tile = new THREE.Mesh(geometry, material);
                tile.position.set(x * this.tileSize, height, z * this.tileSize);
                tile.receiveShadow = true;
                tile.castShadow = true;

                this.scene.add(tile);
                chunkObjects.push(tile);

                // Add trees with varying density
                const treeChance = Math.max(0.05, 0.15 - distance * 0.002); // Fewer trees far away
                if (Math.random() < treeChance) {
                    const treeObjects = this.createTree(x * this.tileSize, height + 1, z * this.tileSize);
                    chunkObjects.push(...treeObjects);
                }

                // Add rocks occasionally
                if (Math.random() < 0.03) {
                    const rock = this.createRock(x * this.tileSize, height + 1, z * this.tileSize);
                    chunkObjects.push(rock);
                }

                this.tiles.set(key, { x, z, height });
                this.tileObjects.set(key, chunkObjects);
                this.totalChunksGenerated++;
            }

            createTree(x, y, z) {
                const treeObjects = [];
                
                // Tree trunk
                const trunkGeometry = new THREE.BoxGeometry(1, 3, 1);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8D6E63 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(x, y + 1.5, z);
                trunk.castShadow = true;
                this.scene.add(trunk);
                treeObjects.push(trunk);

                // Tree leaves
                const leavesGeometry = new THREE.BoxGeometry(2, 2, 2);
                const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.set(x, y + 3.5, z);
                leaves.castShadow = true;
                this.scene.add(leaves);
                treeObjects.push(leaves);
                
                // Add collision
                this.collisionObjects.push({
                    x: x, z: z, y: y,
                    width: 1, height: 4, depth: 1
                });
                
                return treeObjects;
            }

            createRock(x, y, z) {
                const rockGeometry = new THREE.BoxGeometry(
                    0.5 + Math.random() * 0.5,
                    0.3 + Math.random() * 0.4,
                    0.5 + Math.random() * 0.5
                );
                const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x607D8B });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    x + (Math.random() - 0.5) * this.tileSize * 0.8,
                    y + rockGeometry.parameters.height / 2,
                    z + (Math.random() - 0.5) * this.tileSize * 0.8
                );
                rock.castShadow = true;
                rock.receiveShadow = true;
                this.scene.add(rock);
                
                return rock;
            }

            getGroundHeight(x, z) {
                const tileX = Math.floor(x / this.tileSize);
                const tileZ = Math.floor(z / this.tileSize);
                const key = `${tileX},${tileZ}`;
                
                if (!this.groundHeights.has(key)) {
                    // More complex terrain generation
                    const distance = Math.sqrt(tileX*tileX + tileZ*tileZ);
                    const noise1 = Math.sin(tileX * 0.1) * Math.cos(tileZ * 0.1) * 2;
                    const noise2 = Math.sin(tileX * 0.05) * Math.cos(tileZ * 0.05) * 4;
                    const hills = Math.sin(distance * 0.02) * 3;
                    
                    const height = Math.max(0, 1 + noise1 + noise2 * 0.5 + hills);
                    this.groundHeights.set(key, height);
                }
                
                return this.groundHeights.get(key) + 1;
            }

            checkCollision(newX, newZ, playerRadius = 0.5) {
                for (let obj of this.collisionObjects) {
                    const dx = Math.abs(newX - obj.x);
                    const dz = Math.abs(newZ - obj.z);
                    
                    if (dx < (obj.width/2 + playerRadius) && dz < (obj.depth/2 + playerRadius)) {
                        return true;
                    }
                }
                return false;
            }

            handleMovement() {
                // Apply gravity
                this.jumpSpeed += this.gravity;
                this.camera.position.y += this.jumpSpeed;
                
                // Ground collision
                const groundY = this.getGroundHeight(this.camera.position.x, this.camera.position.z) + this.playerHeight;
                if (this.camera.position.y <= groundY) {
                    this.camera.position.y = groundY;
                    this.jumpSpeed = 0;
                    this.isGrounded = true;
                } else {
                    this.isGrounded = false;
                }
                
                // Movement
                const direction = new THREE.Vector3();
                const moveVector = new THREE.Vector3();
                
                if (this.keys['KeyW']) {
                    this.camera.getWorldDirection(direction);
                    direction.y = 0;
                    direction.normalize();
                    moveVector.add(direction);
                }
                
                if (this.keys['KeyS']) {
                    this.camera.getWorldDirection(direction);
                    direction.y = 0;
                    direction.normalize();
                    moveVector.sub(direction);
                }
                
                if (this.keys['KeyA']) {
                    this.camera.getWorldDirection(direction);
                    const left = new THREE.Vector3().crossVectors(this.camera.up, direction);
                    moveVector.add(left);
                }
                
                if (this.keys['KeyD']) {
                    this.camera.getWorldDirection(direction);
                    const right = new THREE.Vector3().crossVectors(direction, this.camera.up);
                    moveVector.add(right);
                }
                
                moveVector.normalize();
                moveVector.multiplyScalar(this.moveSpeed);
                
                const newX = this.camera.position.x + moveVector.x;
                const newZ = this.camera.position.z + moveVector.z;
                
                if (!this.checkCollision(newX, this.camera.position.z)) {
                    this.camera.position.x = newX;
                }
                if (!this.checkCollision(this.camera.position.x, newZ)) {
                    this.camera.position.z = newZ;
                }
            }

            resetCamera() {
                this.camera.position.set(0, 15, 15);
                this.cameraRotationY = 0;
                this.cameraRotationX = 0;
                this.camera.rotation.set(0, 0, 0);
                this.jumpSpeed = 0;
            }

            finishLoading() {
                document.getElementById('loading').style.display = 'none';
                console.log('Infinite world loading complete!');
            }

            updateUI() {
                const pos = this.camera.position;
                document.getElementById('cameraPos').textContent = 
                    `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
                
                document.getElementById('currentChunk').textContent = 
                    `${this.currentChunkX}, ${this.currentChunkZ}`;
                
                document.getElementById('tileCount').textContent = this.tiles.size;
                document.getElementById('totalGenerated').textContent = this.totalChunksGenerated;
                document.getElementById('grounded').textContent = this.isGrounded ? 'Yes' : 'No';
                document.getElementById('renderDist').textContent = this.renderDistance;
                
                const info = this.renderer.info;
                document.getElementById('triangles').textContent = info.render.triangles;
                document.getElementById('drawCalls').textContent = info.render.calls;
            }

            updateFPS(currentTime) {
                this.frameCount++;
                if (currentTime - this.lastFPSUpdate >= 1000) {
                    const fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFPSUpdate));
                    document.getElementById('fps').textContent = fps;
                    this.frameCount = 0;
                    this.lastFPSUpdate = currentTime;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                const currentTime = performance.now();
                this.updateFPS(currentTime);
                
                this.handleCameraRotation();
                this.handleMovement();
                this.updateInfiniteWorld(); // Handle infinite world generation
                this.updateUI();
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        window.addEventListener('load', () => {
            console.log('Page loaded, starting Infinite 3D Map...');
            new InfiniteMap3D();
        });

        window.addEventListener('error', (e) => {
            console.error('Global error:', e.error);
            document.getElementById('loading').innerHTML = '<div style="color: red;">Error: ' + e.error.message + '</div>';
        });
    </script>
</body>
</html>
