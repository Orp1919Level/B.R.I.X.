<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Minecraft World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
            text-align: center;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 150;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: white;
            border: 1px solid black;
        }

        .crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>Generating 3D Map...</div>
            <div id="loadingProgress">0%</div>
        </div>
        
        <div class="crosshair" id="crosshair" style="display: block;"></div>
        
        <div id="info">
            <h3>ðŸŸ« Minecraft World</h3>
            <p>Render Distance: 15x15</p>
            <p>Total Chunks: <span id="tileCount">225</span></p>
            <p>Position: <span id="cameraPos">0, 0, 0</span></p>
            <p>Grounded: <span id="grounded">Yes</span></p>
        </div>

        <div id="controls">
            <h4>Controls:</h4>
            <p>â€¢ Hold Q,E / Arrow Keys: Look left/right</p>
            <p>â€¢ Hold 1,3 / Up,Down: Look up/down</p>
            <p>â€¢ WASD: Move</p>
            <p>â€¢ Space: Jump</p>
            <p>â€¢ R: Reset view</p>
        </div>

        <div id="stats">
            <p>FPS: <span id="fps">60</span></p>
            <p>Triangles: <span id="triangles">0</span></p>
            <p>Draw Calls: <span id="drawCalls">0</span></p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class FlatMap3D {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                this.renderDistance = 15;
                this.tileSize = 10;
                this.tiles = new Map();
                
                this.keys = {};
                this.moveSpeed = 0.3;
                this.jumpSpeed = 0;
                this.gravity = -0.02;
                this.isGrounded = false;
                this.playerHeight = 3;
                
                // Camera rotation variables
                this.cameraRotationY = 0; // Horizontal rotation (yaw)
                this.cameraRotationX = 0; // Vertical rotation (pitch)
                this.turnSpeed = 0.03; // Smooth turning speed
                
                this.lastTime = 0;
                this.frameCount = 0;
                this.lastFPSUpdate = 0;
                
                this.groundHeights = new Map();
                this.collisionObjects = [];
                
                this.loadingProgress = 0;
                this.totalTilesToLoad = this.renderDistance * this.renderDistance;
                
                this.init();
            }

            init() {
                try {
                    console.log('Initializing 3D Map...');
                    this.setupScene();
                    this.setupCamera();
                    this.setupRenderer();
                    this.setupLighting();
                    this.setupEventListeners();
                    
                    setTimeout(() => {
                        this.generateInitialMap();
                        this.finishLoading();
                        this.animate();
                    }, 100);
                    
                } catch (error) {
                    console.error('Error initializing 3D Map:', error);
                    document.getElementById('loading').innerHTML = '<div style="color: red;">Error loading map. Please refresh.</div>';
                }
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
                console.log('Scene created');
            }

            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 15, 15);
                console.log('Camera created');
            }

            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('container').appendChild(this.renderer.domElement);
                console.log('Renderer created');
            }

            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                this.scene.add(directionalLight);
                console.log('Lighting setup complete');
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'KeyR') {
                        this.resetCamera();
                    }
                    if (e.code === 'Space' && this.isGrounded) {
                        this.jumpSpeed = 0.4;
                        this.isGrounded = false;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                console.log('Event listeners setup complete');
            }

            handleCameraRotation() {
                // Smooth continuous rotation while keys are held
                if (this.keys['ArrowLeft'] || this.keys['KeyQ']) {
                    this.cameraRotationY += this.turnSpeed; // Turn left
                }
                if (this.keys['ArrowRight'] || this.keys['KeyE']) {
                    this.cameraRotationY -= this.turnSpeed; // Turn right
                }
                if (this.keys['ArrowUp'] || this.keys['Digit1']) {
                    this.cameraRotationX += this.turnSpeed * 0.7; // Look up (slower)
                    this.cameraRotationX = Math.min(Math.PI/3, this.cameraRotationX);
                }
                if (this.keys['ArrowDown'] || this.keys['Digit3']) {
                    this.cameraRotationX -= this.turnSpeed * 0.7; // Look down (slower)
                    this.cameraRotationX = Math.max(-Math.PI/3, this.cameraRotationX);
                }

                // Apply rotations to camera with auto-leveling
                this.camera.rotation.order = 'YXZ'; // Set rotation order
                this.camera.rotation.y = this.cameraRotationY;
                this.camera.rotation.x = this.cameraRotationX;
                this.camera.rotation.z = 0; // Force level (no roll/tilt)
            }

            generateInitialMap() {
                console.log('Generating initial map...');
                const halfDistance = Math.floor(this.renderDistance / 2);
                let tilesCreated = 0;
                
                for (let x = -halfDistance; x < halfDistance; x++) {
                    for (let z = -halfDistance; z < halfDistance; z++) {
                        this.createTile(x, z);
                        tilesCreated++;
                        
                        this.loadingProgress = Math.floor((tilesCreated / this.totalTilesToLoad) * 100);
                        document.getElementById('loadingProgress').textContent = this.loadingProgress + '%';
                    }
                }
                console.log(`Generated ${tilesCreated} tiles`);
            }

            createTile(x, z) {
                const key = `${x},${z}`;
                if (this.tiles.has(key)) return;

                const geometry = new THREE.BoxGeometry(this.tileSize, 2, this.tileSize);
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0x7CB342
                });

                const height = this.getGroundHeight(x * this.tileSize, z * this.tileSize) - 1;
                
                const tile = new THREE.Mesh(geometry, material);
                tile.position.set(x * this.tileSize, height, z * this.tileSize);
                tile.receiveShadow = true;
                tile.castShadow = true;

                if (Math.random() < 0.1) {
                    this.createTree(x * this.tileSize, height + 1, z * this.tileSize);
                }

                this.scene.add(tile);
                this.tiles.set(key, tile);
            }

            createTree(x, y, z) {
                const trunkGeometry = new THREE.BoxGeometry(1, 3, 1);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8D6E63 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(x, y + 1.5, z);
                trunk.castShadow = true;
                this.scene.add(trunk);

                const leavesGeometry = new THREE.BoxGeometry(2, 2, 2);
                const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.set(x, y + 3.5, z);
                leaves.castShadow = true;
                this.scene.add(leaves);
                
                this.collisionObjects.push({
                    x: x, z: z, y: y,
                    width: 1, height: 4, depth: 1
                });
            }

            getGroundHeight(x, z) {
                const tileX = Math.floor(x / this.tileSize);
                const tileZ = Math.floor(z / this.tileSize);
                const key = `${tileX},${tileZ}`;
                
                if (!this.groundHeights.has(key)) {
                    const noise = Math.sin(tileX * 0.1) * Math.cos(tileZ * 0.1) * 2;
                    const height = Math.max(0, 1 + noise);
                    this.groundHeights.set(key, height);
                }
                
                return this.groundHeights.get(key) + 1;
            }

            checkCollision(newX, newZ, playerRadius = 0.5) {
                for (let obj of this.collisionObjects) {
                    const dx = Math.abs(newX - obj.x);
                    const dz = Math.abs(newZ - obj.z);
                    
                    if (dx < (obj.width/2 + playerRadius) && dz < (obj.depth/2 + playerRadius)) {
                        return true;
                    }
                }
                return false;
            }

            handleMovement() {
                // Apply gravity
                this.jumpSpeed += this.gravity;
                this.camera.position.y += this.jumpSpeed;
                
                // Ground collision
                const groundY = this.getGroundHeight(this.camera.position.x, this.camera.position.z) + this.playerHeight;
                if (this.camera.position.y <= groundY) {
                    this.camera.position.y = groundY;
                    this.jumpSpeed = 0;
                    this.isGrounded = true;
                } else {
                    this.isGrounded = false;
                }
                
                // Movement
                const direction = new THREE.Vector3();
                const moveVector = new THREE.Vector3();
                
                if (this.keys['KeyW']) {
                    this.camera.getWorldDirection(direction);
                    direction.y = 0;
                    direction.normalize();
                    moveVector.add(direction);
                }
                
                if (this.keys['KeyS']) {
                    this.camera.getWorldDirection(direction);
                    direction.y = 0;
                    direction.normalize();
                    moveVector.sub(direction);
                }
                
                if (this.keys['KeyA']) {
                    this.camera.getWorldDirection(direction);
                    const left = new THREE.Vector3().crossVectors(this.camera.up, direction);
                    moveVector.add(left);
                }
                
                if (this.keys['KeyD']) {
                    this.camera.getWorldDirection(direction);
                    const right = new THREE.Vector3().crossVectors(direction, this.camera.up);
                    moveVector.add(right);
                }
                
                moveVector.normalize();
                moveVector.multiplyScalar(this.moveSpeed);
                
                const newX = this.camera.position.x + moveVector.x;
                const newZ = this.camera.position.z + moveVector.z;
                
                if (!this.checkCollision(newX, this.camera.position.z)) {
                    this.camera.position.x = newX;
                }
                if (!this.checkCollision(this.camera.position.x, newZ)) {
                    this.camera.position.z = newZ;
                }
            }

            resetCamera() {
                this.camera.position.set(0, 15, 15);
                this.cameraRotationY = 0;
                this.cameraRotationX = 0;
                this.camera.rotation.set(0, 0, 0);
                this.jumpSpeed = 0;
            }

            finishLoading() {
                document.getElementById('loading').style.display = 'none';
                console.log('Loading complete!');
            }

            updateUI() {
                const pos = this.camera.position;
                document.getElementById('cameraPos').textContent = 
                    `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
                
                document.getElementById('tileCount').textContent = this.tiles.size;
                document.getElementById('grounded').textContent = this.isGrounded ? 'Yes' : 'No';
                
                const info = this.renderer.info;
                document.getElementById('triangles').textContent = info.render.triangles;
                document.getElementById('drawCalls').textContent = info.render.calls;
            }

            updateFPS(currentTime) {
                this.frameCount++;
                if (currentTime - this.lastFPSUpdate >= 1000) {
                    const fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFPSUpdate));
                    document.getElementById('fps').textContent = fps;
                    this.frameCount = 0;
                    this.lastFPSUpdate = currentTime;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                const currentTime = performance.now();
                this.updateFPS(currentTime);
                
                this.handleCameraRotation(); // Handle smooth camera rotation
                this.handleMovement();
                this.updateUI();
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        window.addEventListener('load', () => {
            console.log('Page loaded, starting 3D Map...');
            new FlatMap3D();
        });

        window.addEventListener('error', (e) => {
            console.error('Global error:', e.error);
            document.getElementById('loading').innerHTML = '<div style="color: red;">Error: ' + e.error.message + '</div>';
        });
    </script>
</body>
</html>
